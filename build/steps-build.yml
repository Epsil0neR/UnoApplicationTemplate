parameters:
- name: androidKeyStoreFile
  type: string
  default: ''
- name: iosCertificateFile
  type: string
  default: ''
- name: iosCertificatePassword
  type: string
  default: ''
- name: iosProvisioningProfileFile
  type: string
  default: ''
- name: pathToSrc
  type: string
  default: ''
- name: solutionFileName
  type: string
  default: ''
- name: pathToInfoPlist
  type: string
  default: ''
- name: pathToAndroidManifest
  type: string
  default: ''

steps:
#-if false
- download: current
  condition: eq('GeneratedApp', '${{ parameters.solutionFileName }}')
  artifact: GeneratedApp
#-endif

- task: gitversion/setup@0
  inputs:
    versionSpec: '5.10.1'
  displayName: 'Install GitVersion'

- task: gitversion/execute@0
  inputs:
    useConfigFile: true
    configFilePath: $(Build.SourcesDirectory)/gitversion.yml
  displayName: 'Calculate version'

- task: MSBuild@1
  displayName: 'Restore solution packages'
  inputs:
    solution: '${{ parameters.pathToSrc }}/${{ parameters.solutionFileName }}'
    msbuildLocationMethod: version
    msbuildVersion: latest
    msbuildArchitecture: x86
    msbuildArguments: >
      /t:restore
    configuration: $(ApplicationConfiguration)
    platform: $(ApplicationPlatform)
    clean: false
    maximumCpuCount: true
    restoreNugetPackages: false
    logProjectEvents: false
    createLogFile: false

- task: DownloadSecureFile@1
  name: keyStore
  displayName: "Download keystore from secure files"
  condition: and(succeeded(), not(eq('${{ parameters.androidKeyStoreFile }}', ''))) # Don't run this task when the parameter is empty
  inputs:
    secureFile: ${{ parameters.androidKeyStoreFile }}

- task: android-manifest-package-name@1
  displayName: "Update bundle identifier"
  condition: and(succeeded(), not(eq('${{ parameters.androidKeyStoreFile }}', '')))
  inputs:
    sourcePath: ${{ parameters.pathToAndroidManifest }}
    packageName: $(ApplicationIdentifier)
    appLabel: $(AppLabel) # The label of the app (displayed in launcher and in the OS)
    printFile: true

- task: android-manifest-version@1
  displayName: "Bump android manifest version"
  condition: and(succeeded(), not(eq('${{ parameters.androidKeyStoreFile }}', '')))
  inputs:
    sourcePath: ${{ parameters.pathToAndroidManifest }}
    versionCode: $(PreReleaseNumber)
    versionName: $(MajorMinorPatch)
    printFile: true

- task: InstallAppleCertificate@2
  displayName: 'Install Apple certificate ${{ parameters.iosCertificateFile }}'
  condition: and(succeeded(), not(eq('${{ parameters.iosCertificateFile }}', '')))
  inputs:
    certSecureFile: ${{ parameters.iosCertificateFile}}
    certPwd: ${{ parameters.iosCertificatePassword}}

- task: InstallAppleProvisioningProfile@1
  displayName: 'Install Apple provisioning profile ${{ parameters.iosProvisioningProfileFile }}'
  name: provisioningProfile
  condition: and(succeeded(), not(eq('${{ parameters.iosProvisioningProfileFile }}', '')))
  inputs:
    provProfileSecureFile: ${{ parameters.iosProvisioningProfileFile }}

- task: UpdateiOSVersionInfoPlist@1
  displayName: "Bump iOS version"
  condition: and(succeeded(), not(eq('${{ parameters.iosProvisioningProfileFile }}', '')))
  inputs:
    infoPlistPath: ${{ parameters.pathToInfoPlist }}
    bundleShortVersionString: '$(MajorMinorPatch)'
    bundleVersion: '$(PreReleaseNumber)'

- task: ios-bundle-identifier@1
  displayName: "Replace iOS bundle identifier"
  condition: and(succeeded(), not(eq('${{ parameters.iosProvisioningProfileFile }}', '')))
  inputs:
    sourcePath: ${{ parameters.pathToInfoPlist }}
    bundleIdentifier: $(ApplicationIdentifier)
    bundleName: $(AppLabel) # The label of the app.
    bundleDisplayName: $(AppLabel) # Same as above.
    printFile: true

- task: MSBuild@1
  displayName: 'Build solution in $(ApplicationConfiguration) | $(ApplicationPlatform)'
  condition: and(succeeded(), eq('${{ parameters.iosProvisioningProfileFile }}', ''))
  inputs:
    solution: '${{ parameters.pathToSrc }}/${{ parameters.solutionFileName }}'
    msbuildLocationMethod: version
    msbuildVersion: latest
    msbuildArchitecture: x86
    msbuildArguments: >
      /p:PackageVersion=$(PreReleaseNumber)
      /p:ApplicationBuildNumber=$(PreReleaseNumber)
      /p:ApplicationEnvironment=$(ApplicationEnvironment)
      /p:ApplicationVersion=$(MajorMinorPatch)
      /p:AndroidBuildApplicationPackage=true
      /p:AndroidSigningKeyStore=$(keyStore.secureFilePath)
      /p:AndroidSigningStorePass=$(AndroidSigningStorePass)
      /p:AndroidSigningKeyPass=$(AndroidSigningKeyPass)
      /p:AndroidSigningKeyAlias=$(AndroidSigningKeyAlias)
      /p:AndroidKeyStore=true
      /p:CodesignProvision=$(provisioningProfile.provisioningProfileUuid)
      /p:ApplicationIdentifier=$(ApplicationIdentifier)
      /p:IsLightBuild=$(IsLightBuild)
      /bl
    configuration: $(ApplicationConfiguration)
    platform: $(ApplicationPlatform)
    clean: false
    maximumCpuCount: true
    restoreNugetPackages: false
    logProjectEvents: false
    createLogFile: false

# Build Xamarin.iOS as for now MSBUILD Task keeps using Msbuild from mono
# This task execute a sh script that points directly to VS Msbuild in order to support C#10
- task: Bash@3
  displayName: 'Build Xamarin iOS project'
  condition: and(succeeded(), not(eq('${{ parameters.iosProvisioningProfileFile }}', '')))
  inputs:
    filePath: '$(System.DefaultWorkingDirectory)/build/build-ios.sh'
    arguments: '"${{ parameters.pathToSrc }}/${{ parameters.solutionFileName }}" "$(ApplicationConfiguration)" "$(ApplicationPlatform)" "$(provisioningProfile.provisioningProfileUuid)" "$(ApplicationIdentifier)" "$(PreReleaseNumber)"'

- script: >
    dotnet test ${{ parameters.pathToSrc }}/${{ parameters.solutionFileName }}
    /p:Configuration=$(ApplicationConfiguration)
    /p:CollectCoverage=true
    /p:CoverletOutputFormat=cobertura
    /p:CoverletOutput=${{ parameters.pathToSrc }}/coverage
    /p:ExcludeByFile="**/*.g.cs"
    --logger trx
    --no-build
  displayName: 'Run tests'
  condition: and(succeeded(), eq(variables['ApplicationConfiguration'], 'Release_Tests'))

- task: CopyFiles@2
  displayName: 'Copy binlog (if any) to artifact directory'
  condition: always()
  inputs:
    Contents: '**/*.binlog'
    flattenFolders : true
    TargetFolder: '$(Build.ArtifactStagingDirectory)'

- task: PublishTestResults@2
  displayName: Publish test results
  condition: and(succeeded(), eq(variables['ApplicationConfiguration'], 'Release_Tests'))
  inputs:
    testRunner: VSTest
    testResultsFiles: "**/*.trx"

- task: PublishCodeCoverageResults@1
  displayName: Publish code coverage report
  condition: and(succeeded(), eq(variables['ApplicationConfiguration'], 'Release_Tests'))
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: "${{ parameters.pathToSrc }}/coverage.cobertura.xml"

- task: CopyFiles@2
  displayName: 'Copy AAB'
  inputs:
    Contents: '**/*.aab'
    flattenFolders : true
    TargetFolder: '$(Build.ArtifactStagingDirectory)'

- task: CopyFiles@2
  displayName: 'Copy ipa'
  inputs:
    Contents: '**/*.ipa'
    flattenFolders : true
    TargetFolder: '$(Build.ArtifactStagingDirectory)'

- task: CopyFiles@2
  displayName: 'Copy dSYM'
  inputs:
    Contents: '**/*.dSYM/**'
    flattenFolders: true
    TargetFolder: '$(Build.ArtifactStagingDirectory)/Project.dSYM'

- publish: $(Build.ArtifactStagingDirectory)
  displayName: 'Publish artifact $(ApplicationConfiguration) | $(ApplicationPlatform)'
  condition: always()
  artifact: $(ArtifactName)

#-if false
- task: DeleteFiles@1
  displayName: "Remove downloaded artifacts (GeneratedApp folder)"
  condition: always()
  inputs:
    SourceFolder: $(Pipeline.Workspace)/GeneratedApp
    RemoveSourceFolder: true
    Contents: '**'
#-endif

- task: PostBuildCleanup@3
  displayName: 'Post-Build cleanup :  Cleanup files to keep build server clean!'
  condition: always()
